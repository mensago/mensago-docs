= Mensago Identity Services
:author: Jon Yoder
:email: jsyoder@mailfence.com
:revdate: 2021-01-20
:revnumber: 1.0.2
:description: Structure and description of identity services provided by the Mensago platform
:keywords: Mensago, identity, cryptography, workspaces
:toc: preamble
:table-stripes: odd

*Status:* Draft in progress +

Verifiable identity is the foundation of the Mensago platform. A person or organization's identity is tied to a set of cryptographic keys, and this information is stored in digital certificates called keycards. An organization's server maintains the keycards for all of its users in a blockchain-like database and provides lookup services to that information. 

== Keycard Service Architecture

Mensago identity services are designed to be a loosely-coupled federation, encompassing interaction between directories, resolvers, and issuers. An organization's server plays several roles: an authoritative directory for its domain, a party in the establishment of user identities, an issuer of its own keycard. Users issue their own keycards, but their cards are also signed by their organization. Keycards for all users in the organization are linked together in a tree-shaped blockchain which prevents unauthorized changes to the keycard entries. Keycards are issued only for organizations and users, each providing slightly different types of identity information.

An overview of the resolution process as part of a contact request is as follows:

[arabic]
. Alice gives Bob her Mensago address.
. Bob creates a contact request in his client and clicks Send.
. Bob's client first obtains information from the DNS record for Alice's organization, which includes the organization's current signing and encryption keys.
. Bob’s client requests from the server for Alice's organization both her keycard and that of her organization.
. Bob's client verifies the signatures in the organization's keycard, then the signatures in Alice's keycard, and then verifies her keycard's anchor point.
. Once verified, Bob’s client is ready to create and send Bob’s contact request. It creates the message, signs it with Bob's contact request signing key, encrypts it with Alice’s contact request encryption key, and submits it to his organization’s server for delivery.

A keycard contains multiple entries, from the user’s initial, or *root*, entry on down to the user’s current one. Because an entry is not very large – a few hundred bytes – a full recursive resolution of a keycard does not require much space.

The service architecture for keycards consists of keycard servers and resolvers. Resolvers are similar to DNS resolvers, caching lookups and making requests to authoritative servers for information when needed. Keycard servers store and authoritatively publish keycards for users belonging to their organization.

== Keycard Database Structure

The keycard database is a tree-shaped hybrid blockchain, hereafter called a chain tree. Anyone can to download and view the contents of an individual user, but only authorized users can make changes. In this way, no consensus mechanisms are required. User information is protected in bulk because only requests for individual keycards can be made.


The chain begins with the organization’s root keycard entry and each successive database transaction is linked to the one before it via a cryptographic hash. There are only two possible operation types: append and close: entries can be added to a keycard, and the entire keycard is closed when its owning workspace is deleted. No other changes to a keycard are possible. By adding a new entry to a user's keycard, he or she is revoking the keys in the previous entry. At that point, all old keys are valid only for verifying the signature chain.
 
Several mechanisms are in place to ensure that each keycard is verifiably correct. When a user submits a new entry to their keycard, the organization verifies the information in the entry, generates a signature of the data, and returns the signature to the client. The client then verifies signature using the information on the client's side to ensure that the organization did not change the entry before signing it. It then appends hash of the previous entry, creates a hash of the new entry with this new information, and then signs the entire thing with their contact request signing key. For the user's root keycard entry, the hash of the organization's current keycard entry is used. The signed entry is submitted to the server, which verifies all of the information and signatures and adds it to the database. Thus, both the server and client do not trust each other and each confirms that the other is not doing anything malicious or problematic.

== Mensago Address Fingerprints

As an additional protection against server-based attacks on user data, a Mensago address can also be formatted to include part of the root entry fingerprint. When listed, the address can be separated by a colon from its fingerprint, or the fingerprint can be listed on a separate line. The length of the fingerprint MUST be a minimum of 5 characters, but more may be used. Spaces MAY be used to group characters for better readability IF doing so does not create any parsing problems. Tabs or other whitespace characters MUST NOT be used. Here are some formatting examples:

....
csimons/example.com:V=Vdv

csimons/example.com:V=V dv

csimons/example.com
V=Vdv

csimons/example.com
V=V dv
....

Use of the fingerprint is not a requirement, but it is highly encouraged for the additional security provides.

== The Resolution Process

Obtaining and verifying a recipient's keycard is required before any contact can be made between two users on the Mensago platform. The process is detailed below:

[arabic]
. User A, a member of Organization A, begins creating a signed contact request for User B, who belongs to Organization B.
. The client’s keycard resolver checks the card cache for a copy of a keycard for both User B and Organization B.
. User A’s client connects via TLS to Organization B’s card service and requests the keycards of both User B and Organization B.
. Organization B’s card service looks up and returns the keycards for Organization B and User B – the entire chain of custody – and returns them to User A’s client.
. User A’s resolver, now having both cards and the verification key for Organization B’s keycard, verifies Organization B’s keycard by checking the `Custody-Signature` field of each entry using the contents of the `Verification-Key` field in its predecessor.
. User A's resolver also obtains the current verification key from the DNS management record and makes sure that the keys match that of the current entry for the organization's keycard.
. Having successfully verified Organization B’s keycard, the resolver then verifies User B’s keycard by checking the `Custody-Signature` field with the contents of  the previous entry's `Contact-Request-Verification-Key` field.
. Having verified the user's keycard, the resolver verifies User B's keycard *anchor point*, the entry in the organization's keycard which is hash linked to it. This is done by looking up the entry in the organization's keycard whose hash matches that of the `Previous-Hash` field in the user's root keycard entry.
. User A’s client can trust the information provided. The client creates and signs User A’s contact request with their contact request key, encrypts it with User B’s contact request encryption key, and uploads it to Organization A’s server for delivery.

== DNS Management Records

It is unfortunate that so many security-oriented systems are forced to depend on an insecure system like DNS. Nevertheless, it has proved difficult to replace. DNS records are used by keycard resolvers to obtain basic configuration information and as a way to validate organization keycards.

Securing a domain’s resource records with DNSSEC cannot be recommended enough. When DNSSEC signatures are present, a hash of the public key in the server's TLS certificate in DNS and used to validate the domain’s TLS certificate. In such situations, a certificate signed by a recognized third-party certificate authority (CA) is not required. In light of CA compromises in recent years, this is a notable benefit. Without the presence of DNSSEC, resolvers MUST require the TLS certificate of a Mensago server to be signed by a recognized third party CA.

Aside from the optional SRV record used for client autoconfiguration, TXT records are required, providing a second source of information about a server. The organization's Primary Verification Key is required to be stored in DNS and is used to assist in confirming a server's identity. 

When working with DNS TXT records and the maximum length of 255 characters per string, fields MUST NOT be split across strings. A good policy for TXT record fields would be one string per field. Likewise, for maximum compatibility, DNS responses should be no longer than 512 bytes. Given the short length of Mensago DNS record fields, this should not be difficult.

=== Server Autodiscovery

Given the complicated nature of configuring e-mail clients, automatic configuration is considered a requirement for the platform. An administrator can add an SRV record to inform clients of the fully-qualified domain name and port used by its Mensago server. This DNS record is optional. If not provided, clients check if the organization has a `mensago` subdomain, i.e. `mensago.subdomain.example.com` and, if not, work its way up the domain hierarchy. For example, for the domain `subdomain.example.com`, a client would perform the following steps:

. Check for an SRV record with the service type `_mensago`, and use the supplied FQDN and port if it exists
. Perform a DNS lookup for `mensago.subdomain.example.com`
. Perform a DNS lookup for `mensago.example.com`
. Attempt to connect to `example.com`

The default port, 2001, is always used unless there is an SRV record in DNS which specified otherwise. If there is no SRV record and nothing is found at any of the specified subdomains, the organization is assumed to not offer Mensago services.

=== Management Record Fields

These fields are part of the TXT record for an organization's DNS configuration.

pvk:: REQUIRED. This contains the CryptoString-formatted verification key for the organization signature found in the organization’s current keycard entry. It MUST match the key in the `Primary-Signing-Key` field of the organization's current keycard entry. Resolvers MUST reject any keycard which does not validate with a verification key from the management record. 

svk:: CONDITIONAL. This contains the secondary verification key and corresponds to `Secondary-Verification-Key`. As a matter of course, when a keycard is updated, the key in the `pvk` field is usually converted to an `svk` field unless the key was revoked. If the `pvk` key was revoked, the `svk` field should be empty and the new entry in the organization's keycard should NOT have a `Secondary-Signing-Key` field. If the current entry in the organization's keycard contains this field, the DNS record MUST be present. 

tls:: OPTIONAL. This field contains a CryptoString-formatted hash of the public key found in the server's TLS certificate. Although optional, use of this field is highly recommended. Because of the 255 byte limit on TXT records, it is recommended that this field be put into its own TXT record and a 128-bit or 192-bit hash be used.

== Lifecycle: Rotation and Revocation

Proper key management includes occasional replacement to guard against compromise. Because of their public nature, a user’s contact request keys are recommended to be rotated at least every 90 days. While the general-purpose user encryption keys SHOULD be rotated at the same time, this is not a requirement. Organizational keys require more work to rotate, so their keycard entries have a lifespan of 1 to 3 years. Each device has a unique encryption key; these device keys should be rotated every 30 days. A user will have other keys, such as signing and encryption keys for each contact. These should be rotated, as well, but frequency is specific to the particular task (address books, calendars, etc.).

Key revocation is not a difficult process for Mensago applications. Keys found in keycards, particularly those on user keycards, are designed to be easily rotated and intended to be treated as ephemeral. Revoking a key in a user set is merely a matter of updating the keycard. Revoking a key for an organization is just a matter of updating the keycard, not converting the primary signing key to a secondary, and updating the DNS record accordingly.

With the extensive use of cryptographic keys, key security is critical. Client software MUST provide encrypted storage of the user's keys. If a user's device is compromised and the keys are stolen, the attacker still cannot pretend to be the victim unless the user's password is also known. Rotating the compromised device's encryption key would be an effective next step to stop the attacker. Even then, if the server detects two different sessions with the same device, an alert can be sent to all of the user's devices to notify all parties that the user's account has been compromised. In the event that an attacker has the user's password and keys and has locked the user out of the account, the best choice at that point is for the server administrator to deactivate the workspace. Although the workspace has been effectively lost in such a situation, the user still retains all data on their devices.

== Field Definitions and Formatting

A keycard entry consists of a series of 1-line key-value pairs. Most of a keycard’s fields are relatively self-explanatory. Fields are expected to be listed on a keycard in the order below, but with the exception of signature fields, cryptographic hash fields, and the Type field, readers and resolvers MUST NOT consider a keycard invalid because of a different ordering of data fields so long as the the fields themselves meet all other requirements. The Type field MUST be first. The signature and hash fields are required to be in order as listed, and any entry which deviates from this order MUST be considered invalid. Each field is terminated by a carriage return-newline sequence (`\r\n`). All fields MUST be trimmed of leading and trailing whitespace except for the line ending. Field data has a maximum length of 6144 bytes in case it is ever necessary to accommodate 4096-bit RSA keys. Keycard fields are required unless indicated otherwise.

Fields which contain encryption keys, verification keys, and entry hashes follow a particular subformat called CryptoString. It was designed to enable future algorithm changes. First, the field contains a prefix describing the algorithm used. This prefix has a maximum length of 24 characters, not including the colon, and MUST contain only capital letters, numbers, or dashes. The prefix is followed by a colon and then the Base85-encoded key or hash. An example looks like this: `Contact-Request-Verification-Key:ED25519:q~NVs$%Z82g7ZfniK3@!N+FrzcYJnawDdyYa!}@W`. Currently the only supported algorithms are `ED25519` for signing, and `CURVE25519` for encryption. RSA is not supported to prevent database bloat, but the platform has been architected to permit them should the need arise. `AES-256` and `XSALSA20` are the supported symmetric encryption algorithms. More hash algorithms are supported: `BLAKE2B-256` is preferred for its speed without hardware acceleration, followed by `SHA-256`, and `SHA3-256`.

=== Organizational Keycards

Keycards which represent an organization contain both cryptographic information and some other data needed for basic identification and administration. Because of the extra effort required to update keycards when combined with DNSSEC, organizational keycards are intended to have lifespans of 1-3 years. Organizational keycards are self-signed using the organization’s primary signing key. When organizational keycard entries are updated, a new primary signing key MUST be created and the previous primary key SHOULD be included as the secondary signing key unless the previous primary key has been revoked.

*Purposes*

[arabic]
. Signing user keycards
. Encrypting delivery information (sender, recipient)
. Signing outgoing messages
. Making available necessary contact and support information for the organization

Index:: The index of the entry in the organization’s keycard. The index for the first entry in a keycard is always 1. Each successive entry increments this value. Its purpose to easily order all entries in the keycard.

Name:: The name of the organization represented by the keycard, which must meet the following criteria: (1) contain at least 1 and no more than 64 Unicode codepoints, (2) must contain at least 1 printable character, and (3) like all other fields, not have any leading or trailing whitespace except for the `\r\n` line ending.

Contact-Admin:: the numeric address for the party responsible for administrating the Mensago services for the organization. Example: `6321fb6e-c68c-4279-a1f4-68f05a2bb9b0/example.com`. Support requests and abuse reports are sent to this address if the `Contact-Support` and `Contact-Abuse` fields are not populated.

Contact-Abuse:: OPTIONAL. The Contact-Abuse field contains a numeric address for reporting abuse to the service administrator. If omitted, abuse reporting is sent to the address in the Contact-Admin field. If included and valid, this field MUST be used for abuse reporting. Provided that the server is configured correctly and the abuse address is valid, an administrator MAY opt to drop abuse messages sent to `Contact-Admin` or autoreply with a bounce message to ensure clients follow support protocols. Note that abuse reports have a specific format defined in the Mensago messaging design document.

Contact-Support:: OPTIONAL. The Contact-Support fields contains a numeric address for requesting organizational support. It is intended for use ONLY by users from the organization itself, and support requests sent to this address. If omitted, support requests are sent to the address in the Contact-Admin field. If included and valid, this field MUST be used for support requests. Provided that the server is configured correctly and the support address is valid, an administrator MAY opt to drop support requests sent to `Contact-Admin` to ensure clients follow support protocols. Note that support requests have a specific format defined in the Mensago messaging design document.

Language:: Comma-separated list of https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes[ISO 639-1] language codes which indicated languages supported when contacting the organization. Up to 10 languages may be specified. Example: `en,fr,de`.

Primary-Verification-Key:: The primary signing key for the organization in CryptoString format.

Secondary-Verification-Key:: The secondary signing key for the organization in CryptoString format. When keys are rotated, often this key is the organization’s previous `Primary-Verification-Key`.

Encryption-Key:: The public encryption key for the organization in CryptoString format.

Time-To-Live:: Number of days in which the keycard may remain in a resolver cache. Recommended value is 14, but MUST NOT be more than 30 or less than 1. After this period of time, a resolver MUST check to ensure that the keycard has not changed.

Expires:: The date after which this keycard is considered to be expired. Because keycards themselves are not associated with any costs, ensuring an organization ALWAYS has a valid keycard is paramount to the security of its users. Keycard resolvers and clients MUST refuse to deliver messages to domains with expired keycards.

Timestamp:: The time and date when the entry was created. The format is expected to be in the ISO8601 format `YYYYMMDDTHHMMSSZ`, implying the UTC timezone.

Custody-Signature:: The Base85-encoded chain-of-custody signature in CryptoString format. This field does not exist in an organization’s first keycard entry. It MUST follow the last informational field of the entry if it exists. The signature includes all previous fields and is signed with private half of the `Primary-Verification-Key` field from the previous entry. This field is required EXCEPT for the first entry of the organization's keycard.

Previous-Hash:: The `Hash` field of the previous entry in the organization's keycard. Because it is the first entry in the entire keycard database, an organization’s root keycard entry will not have this field, but for all others it is required.

Hash:: The hash of all fields listed above. This field is used for identification of the keycard entry in the organization’s database.

Organization-Signature:: Signature of the keycard using the signing key corresponding to the key in the organization’s `Primary-Verification-Key` field. This field is the final field of the entry.

=== User Keycards

Unlike organizational keycards, individual keycards are designed specifically for setting up encrypted communications between two entities while containing as little personally-identifiable information as possible. Like organizational keycards, all fields are one-line key-value pairs terminated by `\r\n` and all fields are required unless otherwise indicated.

Index:: The index of the entry in the user’s keycard. The index for the first entry in a keycard is always 1. Each successive entry increments this value. Its purpose to easily order all entries in the keycard.

Name:: OPTIONAL. The name of the person represented by the keycard. If this field exists, it must meet the following criteria: (1) contain at least 1 and no more than 64 Unicode codepoints, (2) must contain at least 1 printable character, and (3) like all other fields, not have any leading or trailing whitespace except for the `\r\n` line ending.

Workspace-ID:: a version 4 Universally-Unique Identifier (UUID) which is used to identify the workspace. This number is fixed for the lifetime of the workspace and is unique to the server. It also MUST not be reused once a workspace has been deleted.

User-ID:: a human-friendly name for the workspace. Its relationship to the `Workspace-ID` field is similar to that of a DNS name to an IP address. The workspace user MAY change this at any time, but a new keycard entry MUST be created to do so. It is to be used for human identification of a workspace, such as display in a client application. Any UTF-8 printable character except the forward slash (`/`), the backslash (`\`), and the double quotation mark (`"`) MAY be used in this field. Whitespace characters (tab, space, non-breaking space, etc.) are NOT permitted. The user ID may have up to 64 Unicode code points, although for the sake of ease of use, it recommended to be much shorter than the maximum. Only one workspace at an organization may have a given name at any time, although the workspace to which said name corresponds may change, and this being one reason why supplying the fingerprint with a person's Mensago address is helpful--no mistaken identities.

Domain:: The domain to which the workspace belongs, such as `example.com`. This is not required to match the Domain field of the organization, but if it is different, the account MUST be preregistered by an administrator with the desired domain. The maximum length for this field is 255 characters.

Contact-Request-Encryption-Key:: the public half of a key pair in CryptoString format which is used to encrypt contact requests. 

Contact-Request-Verification-Key:: the public half of a signing key pair in CryptoString format for verifying the signature on a contact request.

Public-Encryption-Key:: a public key in CryptoString format for third party use. Possible uses include website authentication or PGP. Although reserved, this field is required.

Alternate-Encryption-Key:: OPTIONAL. another public key in CryptoString format for third party use.

Public-Verification-Key:: a verification key in CryptoString format for third party use. Possible uses include signing documents and other files.

Time-To-Live:: Number of days in which the keycard may remain in a resolver cache. Recommended value is 7, but it MUST NOT be less than 1 or greater than 30. After this period of time, a resolver MUST check to ensure that the keycard has not changed.

Expires:: The date after which this keycard is considered to be expired. Keycard resolvers and clients MUST refuse to deliver messages to users with expired keycards.

Timestamp:: The time and date when the entry was created. The format is expected to be in the ISO8601 format `YYYYMMDDTHHMMSSZ`, implying the UTC timezone.

Custody-Signature:: The chain-of-custody signature in CryptoString format. This field does not exist in a user’s first keycard entry. It MUST be the first field following the standard informational fields and MUST be the first of the three signatures on a user keycard if it exists. It contains the signature for all previous fields and is signed with the private half of the `Contact-Request-Verification-Key` of the previous keycard entry.

Organization-Signature:: A CryptoString-formatted signature of all fields listed above, including the `Custody-Signature` field if it exists. It is signed using the organization’s primary signing key.

Previous-Hash:: The `Hash` field of the previous entry in the user's keycard or, for the user's root entry, the hash of the organization's current entry at the time of the workspace's creation.

Hash:: The hash of all fields listed above. This field is used for identification of the keycard entry in the organization’s database.

User-Signature:: The signature of all previous fields in CryptoString format. This signature is the final field in the entry.

== Session Authentication

Currently there is only one type of authentication supported, PLAIN, which is a multstep process that confirms the identity of both parties. The process is outlined below:

. The client application connects and submits a workspace ID and encrypted server challenge
. The server confirms the workspace ID is valid and returns the decrypted challenge
. The client submits the user's hashed password.
. The server hashes the user's hashed password, compares the result to the stored value, and returns success if they match
. The client submits the device's unique UUID and device encryption key.
. The server checks for the existence of the device.
. If the device does not already exist, the server initiates multifactor authentication to permit the device (process described below)
. If the device is found, the server returns with a challenge encrypted with the device's encryption key
. The device responds with the decrypted challenge, the server confirms a match, and the session is authenticated.

Challenges in this process are multilayered. First, a 32-byte string of random bytes is generated. This random series of bytes is then Base85-encoded. The encoded challenge is then encrypted and then Base85-encoded a second time. This 50-byte challenge is sent to the other party. The other party decodes the challenge, decrypts it, and returns the original challenge in Base85-encoded format. This process is JSON-friendly and string comparisons are much easier -- and possibly faster -- than comparing two byte arrays in some programming languages.

User passwords are expected to be hashed using the Argon2id password hashing algorithm before being submitted to the server, and the server will hash the user's hashed password, providing additional protection from bruteforce attacks if the server should ever be compromised.

Device Checking is a lightweight form of multifactor authentication that also assists with key synchronization among multiple devices on a workspace. When a new device attempts to log into a workspace when Device Checking is enabled, the server queues a Device Alert system message (see below) in the workspace. Devices who find the message show an alert to the user which asks if the user is logging in on another device and requests approval or denial of the device. If the device is approved, the user's client software packages the user's keys into a JSON structure, encrypts it with an ephemeral symmetric key tied to a randomly-generated password, Base85-encodes it, attaches the package to the response, sends the response to the server, and displays the password to the user. The server responds to the new device with the encrypted key package, and the client on the new device requests the PIN from the user so that it can decrypt the key package. The server also adds the new device's key and ID to the list of approved devices for the workspace. This extra set of steps ensures that a user remains secure while minimizing the amount of annoyance that traditional multifactor authentication imposes.

=== Device Alerts

When a new device is added to a Mensago workspace, an alert is sent to the user's other devices. A sample payload for the initial device alert is shown below.

[source,json]
----
{
    "Type" : "sysmessage",
    "SubType" : "DevAlert.1",
    "Version" : "1.0",
    "From" : "example.com",
    "To" : [ "662679bd-3611-4d5e-a570-52812bdcc6f3/example.com" ],
    "Date" : "20190905T155323Z",
    "Attachments" : [
        {
            "Request-ID" : "e1f4ddc7-3011-468a-9b52-da0c065fc773",
            "Device-Name" : "my laptop",
            "Device-IP" : "172.20.5.10",
            "Device-Description" : "Acme Supertop 17\"",
            "Device-Key" : "CURVE25519:7CRSc1J&VFreXZUX{dI-;W+%tS0ivN_g{j?^w4fm"
        }
    ]
}
----

All fields are required except for `Device-Name` and `Device-Description`. The `From` field is the domain for the organization, which may or may not be the same as that of the recipient. The payload is encrypted using the recipient's contact request encryption key. Like all system messages, it is signed by the organization's primary signing key. Below is a sample approval message payload.

[source,json]
----
{
    "Type" : "sysmessage",
    "SubType" : "DevAlert.2",
    "Version" : "1.0",
    "From" : "662679bd-3611-4d5e-a570-52812bdcc6f3/example.com",
    "To" : [ "example.com" ],
    "Date" : "20190905T155437Z",
    "Attachments" : [
        {
            "Request-ID" : "e1f4ddc7-3011-468a-9b52-da0c065fc773",
            "Status" : "approved",
            "KeyPackageKey" : "/ settings a7c20afd350f846ae97e9c82b82ee10c0.1",
            "KeyPackage" : "/ settings fc9c29e03c9fe24e99f285e93df5206dc.1",
            "Key" : "CURVE25519:2^p(aU^P%mQN;QtA+iO>kso}ux%s1)2zKq(n>d~)r}bfVsNd=OxTNWD2o)Y6"
        }
    ]
}
----

This payload is an example of one of the few messages that are sent directly to the organization using just the domain. The message is encrypted with the organization's encryption key. The `KeyPackage` field contains the path to the encrypted file containing the user's complete set of crypto keys. The key which is used to encrypt this key package is encrypted with the device's encryption key and stored in the file listed in the `KeyPackageKey` field. The package key, in addition to being protected by the device's encryption key, is also encrypted using 256-bit AES-GCM with a randomly-generated 12-character password. Once received by the server, the server responds with `200 OK` with the necessary data attached. The success response is listed below.

[source,json]
----
{
    "Code" : 200,
    "Status" : "OK",
    "Attachments" : [
        {
            "Request-ID" : "e1f4ddc7-3011-468a-9b52-da0c065fc773",
            "Status" : "approved",
            "KeyPackageKey" : "/ settings a7c20afd350f846ae97e9c82b82ee10c0.1",
            "KeyPackage" : "/ settings fc9c29e03c9fe24e99f285e93df5206dc.1",
            "Challenge" : "bbW1bZ%;~gV@o$ScT941V>fduCVoz6dnrC?d00<ZP;pdWUPwnx"
        }
    ]
}
----

Once received by the new device, the user is prompted to enter the password from the other device. The device uses the password to decrypt the file listed in the `KeyPackageKey` field, decrypts the file listed in `KeyPackage`, deletes the file, installs the set of keys, returns the decrypted challenge to the server, and login is complete.

== Registration and Workspace Setup

Registration is the process of creating a workspace account on a server. There are four types of registration modes which adjust the level of control the administrator has over the process. The four modes are private, moderated, network, and public.

Private registration, which is the default, grants the administrator the greatest control. In private mode, all registration must be performed by the administrator. Preregistration gives the administrator the option of choosing the specific workspace ID for the account, the user ID, and/or the domain. The domain, in fact, can only be set this way for an account if it is different from that of the server. When the administrator preregisters an account, a registration code is created. The administrator gives the workspace ID, the user ID -- if there is one --, and the registration code. The user then uses the preregistration process in the client software to set a password and finish the registration process. In this mode, the user can request closure of the workspace, but it must be approved by the administrator for it to take effect.

Moderated registration gives users the ability to create an account, but with administrator approval. The user may specify the workspace ID and/or the user ID, but nothing else. Once the registration request is made by the user, the administrator approves it, and only then is the workspace created. Like private mode, workspace closure requires administrator approval.

Public registration is generally not recommended except in special cases. This mode allows anyone to create or delete an account just by asking for it.

Network registration is similar to public registration, but it confines the ability to register and unregister an account to a specific subnet. This option is great for self-hosted servers on home networks and small businesses with just a few employees, as anyone on the local network can easily set up a workspace and use it without any IT intervention.

Once registration is complete, the workspace has been created, but one more step is required to make the new workspace usable: uploading the user's root keycard entry and directory sync setup. Clients should follow a successful REGISTER or PREREG command with ADDENTRY and MKDIR commands to create on the server to create directorys needed for data synchronization.

== Paranoid Mode

Paranoid Mode is feature not technically a required for Mensago clients to implement, but is encouraged. Simply put, it is a set of security settings for those users who are particularly concerned about their data security. It is designed to quickly configure a user's client for maximum security and privacy and should be configured per-profile. It is also recommended that implementors provide some visible way to display to the user that the client is operating in Paranoid Mode. It consists of the following settings:

- Automatically reject all New Device alerts, restricting access to only one device and reducing server-side data storage to just messages waiting for delivery.
- Preventing the use of a User ID or Name in a keycard
- Set keycard rotation interval to 1 day
- Set device key rotation interval to 1 day
- If the client normally makes local encryption optional, require local encryption for all data
- Disable local password caching
- Require minimum 12 character password with complexity
- Set checking for incoming messages and sending of outgoing messages to Manual
- A warning is shown when sending a contact request to an address without a fingerprint

Although this sounds extreme, in practice, it does not impose significant extra effort. Upon startup, the client asks for password upon startup and it has to be reasonably strong. The user clicks a button or uses a keyboard shortcut when they want to check for new messages and send outgoing messages. The user's contacts are given a workspace address instead of an alphanumeric Mensago address, and only one computer is used for said address. A tradeoff of using Paranoid Mode is that all information for that profile is stored only on that computer; the user would be wise to set up some sort of backup solution to prevent data loss.

== Protocol Commands

Client-Server messages use JSON with three fields required for all messages.

* *Code* : an integer status code. See the Client-Server API documentation for a list of codes.
* *Status* : the message corresponding to the status code. Also in the Client-Server API documentation.
* *Data* : a dictionary containing attached data, which is used for call parameters and return values. All parameters and return values are strings.


=== ADDENTRY

_Adds a keycard entry to the database_ +
[cols="1,3a"]
|===
| Parameters | None
| Returns | See below
|===

Begins the process for submitting a keycard entry to the organization’s database.

[arabic]
. Client sends the `ADDENTRY` command, attaching the entry data to the `Base-Entry` field.
. The server then checks compliance of the entry data. Assuming that it complies, the server generates a cryptographic signature and responds with `100 CONTINUE`, returning the signature (`Organization-Signature`).
. The client verifies the signature against the organization’s verification key. This has the added benefit of ensuring that none of the fields were altered by the server and that the signature is valid.
. The client appends the hash from the previous entry as the `Previous-Hash` field. For a root user entry, this is the hash of the current organization entry.
. The client generates the hash value for the entry as the `Hash` field
. The client signs the entry as the `User-Signature` field and then uploads the result to the server.
. Once uploaded, the server generates the values needed for the `Previous-Hash` and `Hash` fields and validates the `User-Signature` field. Assuming that all is well, the server adds the complete entry to the keycard database and returns `200 OK`.

This extensive process is designed to prevent either side from doing anything improper, such as server-side man-in-the-middle attacks, uploading invalid data, or other tricks. When added, it is safe to assume that the data is mutually validated and that the data itself is trustworthy even if neither party is trusted by the other. Each line in the entry MUST be terminated by a carriage return-line feed (`\r\n`) sequence to ensure that the signatures remain valid. In the case of a user entry, the Domain field MUST NOT be changed. Any change to the Domain field will result in a `401 UNAUTHORIZED` response.

=== CANCEL

_Gracefully cancels out of a multistep command_
[cols="1,3a"]
|===
| Parameters | None
| Returns | * 200 OK
|===

This command is used to reset the session to a sane state if the client wishes to cancel a multistep command, such as ADDENTRY. It can also reset the session state to the basic, unauthenticated state (similar to LOGOUT) if used during the multistep PLAIN login process. Unlike LOGOUT, it does not return the session to an unauthenticated state if issued while fully authenticated; it merely resets the session to a ready state for the next command.

=== DEVKEY

_Updates an existing device's encryption key_
[cols="1,3a"]
|===
| Parameters | * Device-ID
* Old-Key
* New-Key
| Returns | * 100 CONTINUE
** Challenge
** New-Challenge
* 200 OK
| Possible Errors | * 306 KEY FAILURE
|===

This command is for rotating the encryption key used to uniquely identify a device to the server for a workspace. The key is expected to be submitted in CryptoKey format. Once received, the server undergoes the same challenge-response procedure for authenticating the device as the DEVICE command, but for both the old key on file and the new key. The device is expected to return the decrypted challenges in the fields Response and New-Reponse. If both decrypted challenges match, the server replaces the old key with the new and returns 200 OK.


=== DEVICE

_Finishes PLAIN authentication_
[cols="1,3a"]
|===
|Parameters 
| * Device-ID
* Device-Key
* _optional:_ Device-Name
* _optional:_ Device-Description
* Response _(second phase only)_

| Returns | . 100 CONTINUE
** Challenge
. 200 OK

| Possible Errors
| * 101 PENDING
* 401 UNAUTHORIZED
* 403 FORBIDDEN
|===

The DEVICE command is the final step in the PLAIN authentication process. The client submits the device’s unique ID and CryptoString-formatted encryption key. Devices are responsible for generating their own IDs if they have not been added to the workspace.

If a device’s ID and key are not found, `101 PENDING` is returned if device checking is enabled and approval is pending. While approval is pending, this command MAY be reissued to check approval status. Checks MUST NOT be performed more than once every 10 seconds. While approval is pending, `101 PENDING` will still be returned. If device approval is denied, `403 FORBIDDEN` is returned.

If the device is approved or is already in the server’s device list, `100 CONTINUE` is returned along with a device challenge, which is a 32-bit random string that is then Base85 encoded, encrypted with the device's encryption key, and then Base85-encoded a second time. The device MUST respond with the same command along with the Base85-encoded decrypted challenge. If the device does not respond with the correct string, `401 UNAUTHORIZED` is returned, the login process is ended, and the session returns to the baseline unauthenticated state. Assuming that the correct challenge is sent, `200 OK` is returned and the PLAIN authentication process is successful and complete.

The `Device-Name` and `Device-Description` two optional fields are used for first-time logins of devices. If a user's client software has not logged into a workspace before, it can also submit information in these two fields to be included in the device alert and displayed to the user. `Device-Name` should either contain a phrase supplied by the user prior to login or the hostname of the device. `Device-Description` should be the make and model of the device.

=== GETWID

_Resolves a Mensago address to a workspace ID_

[cols="1,3a"]
|===
| Parameters
| * User-ID
* Domain _(optional)_

| Returns 
| * 200 OK
** Workspace-ID
* 404 NOT FOUND
* 414 LIMIT REACHED
* 405 TERMINATED
|===

The GETWID command looks up the specified user ID and returns the associated workspace ID. If a domain is not specified, the organization's domain is used. `404 NOT FOUND` is returned if the user ID does not exist. `414 LIMIT REACHED` is returned if the client has exceeded the configurable server lookup limit, which defaults to 100 in 60 seconds. This limit exists to protect the privacy of the users. Similar to the LOGIN command, if the client submits too many requests which result in a `404 NOT FOUND`, the server will terminate the connection and impose a short cooldown period for the offending IP address. The default settings for this 50 failed lookups in the span of 5 minutes, which results in a cooldown of 30 minutes. This command does not require an authenticated session.


=== ISCURRENT

_Verifies that an entry is the current one_

[cols="1,3a"]
|===
| Parameters
| * Index
* Workspace-ID _(optional)_

| Returns 
| * 200 OK
** Is-Current
|===

This command verifies that the supplied index is the current one for the workspace specified or the organization. If the Workspace-ID parameter is omitted, the lookup is performed for the organization. On success, the response is either `YES` or `NO`. The client is not required to be authenticated for this command.

=== LOGIN

_Initiates authentication_

[cols="1,3a"]
|===
| Parameters
| * Login-Type
* Workspace-ID
* Challenge
| Returns 
| * 100 CONTINUE
** Response

| Possible Errors
| * 404 NOT FOUND
* 405 TERMINATED
|===

Starts the authentication process. Currently, the only type of authentication is PLAIN, which is a multistep username/password/device challenge-response login. In this phase of the login process, the client creates a random 32-byte challenge which is Base85-encoded, encrypted with the organization's encryption key, and then Base85-encoded a second time. The organization's encryption key is obtained from the `Encryption-Key` field of the organization's keycard. Assuming that the specified workspace is found, the server is expected to decrypt and return the Base85-encoded challenge in its response to the client's login request. The decrypted challenge is required to be returned only if the status code is `100 CONTINUE`. If the workspace ID doesn’t exist, `404 NOT FOUND` is returned. If multiple failures are made and reaches the server’s failure limit, `405 TERMINATED` is sent and the connection is closed. If the workspace is pending moderator approval, `101 PENDING` is returned. Success is indicated by `100 CONTINUE`, at which point the PLAIN authentication process advances to the PASSWORD command step.

=== LOGOUT

_Logs out of the session_ 

[cols="1,3a"]
|===
| Parameters | None
| Returns | * 200 OK
| Possible Errors | None
|===

Returns the session to an unauthenticated state. This does not close the connection. `200 OK` is returned regardless of whether the session is currently authenticated or not.

=== ORGCARD

_Requests the organization keycard_

[cols="1,3a"]
|===
| Parameters
| * Start-Index
* _optional:_ End-Index

| Returns | * 104 TRANSFER
** Item-Count
** Total-Size

| Possible Errors
| * 400 BAD REQUEST
* 404 NOT FOUND
|===

Requests part or all of the organization’s keycard, given the starting index and possibly an end index. The client is not required to be authenticated for this command. If the ending index is omitted, all cards from the specified entry through the organization’s current keycard are returned. If the starting index is set to 0 or a negative number, only the organization’s most recent entry is returned.

Once the command is submitted, the server responds with the number of entries and the total byte size of the transfer. The server is expected to respond with an empty TRANSFER command to confirm the transfer. Once confirmed, the server transmits the all of the requested entries. Each keycard entry has a `----- BEGIN ORG ENTRY -----` header line and a `----- END ORG ENTRY -----` footer line. Both are markers of the entry data without being part of the entries themselves. `400 BAD REQUEST` is returned if `end_index` is less than `start_index`. `404 NOT FOUND` is returned if the server cannot find any entries for the organization, which means a bad day for the server administrator.

=== PASSCODE

[cols="1,3a"]
|===
| Parameters | * Workspace-ID
* Reset-Code
* Password-Hash
| Returns | * 200 OK

| Possible Errors 
| * 402 AUTHENTICATION FAILURE
| * 415 EXPIRED
* 405 TERMINATED
|===

This command corresponds with RESETPASSWORD, permitting a user to change their password if it has been forgotten by using a one-time-use reset code along with the hash of their new password and their workspace ID. Once successful, it will be necessary for the user to re-enter their password on all of their devices. `402 AUTHENTICATION FAILURE` is returned if the combination of workspace ID and code are not found. Just like for the LOGIN or PASSWORD commands, authentication failures are to be logged per IP address, and if the failure count reaches the server's failure limit, `405 TERMINATED` is returned and the connection is terminated. `415 EXPIRED` is returned if the password reset is attempted after its expiration time has been reached. Server implementations should remove an expired password reset record if a user attempts to perform a password reset with it. Server implementations should also periodically check for and remove expired password reset records, as well.

=== PASSWORD

_Submits password for authentication_

[cols="1,3a"]
|===
| Parameters | * Password-Hash
| Returns | * 100 CONTINUE

| Possible Errors 
| * 402 AUTHENTICATION FAILURE
* 405 TERMINATED
|===

Continues PLAIN authentication. MUST be sent only if client receives `100 CONTINUE` from a LOGIN command. If the hashes don’t match, `402 AUTHENTICATION FAILURE` is returned and the session state returns to its original, unauthenticated state–after any PASSWORD failure, a successful `LOGIN` MUST be sent to be permitted to send another `PASSWORD` command. If the password failure max for the server is reached, `405 TERMINATED` is sent and the connection is closed. After the successful response, the PLAIN login process advances to the DEVICE phase.

=== PREREG

_Provisions a new workspace_

[cols="1,3a"]
|===
| Parameters
| * _optional:_ Workspace-ID
* _optional:_ User-ID
* _optional:_ Domain

| Returns
| * 200 OK
** Workspace-ID
** Reg-Code
** Domain
** User-ID

| Possible Errors | * 408 RESOURCE EXISTS
|===

Requests the creation of a new workspace. Unlike REGISTER, this command is intended to be issued by the administrator from an authenticated state. This command may be used with any of the registration modes, although it is of limited utility for servers configured for public or network registration. The administrator may specify the desired workspace ID and/or the desired user ID. If the workspace is to have a domain different from the default, it MUST be specified here -- neither the administrator nor the user have any control to set the domain for a workspace outside of this command. It returns a workspace ID, a registration code, and if a user ID was supplied, the user ID originally requested. The administrator gives the workspace ID (or user ID) and preregistration code to the user. The code is not a password; it is only a means of authenticating a user for registration without the administrator ever knowing the user’s password. Preregistration codes generated by the server MUST be at least 8 Unicode codepoints. It is highly recommended that implementations generate preregistration codes using the https://en.wikipedia.org/wiki/Diceware[Diceware] method with a minimum of 4 words and an appropriate word list.

=== QUIT

_Request closing the connection_

[cols="1,3a"]
|===
| Parameters | None
| Returns  | None
|===

Requests the server close the connection. The server does not return anything; instead the server closes the connection.

=== REGCODE

_Logs in with preregistration information_

[cols="1,3a"]
|===
| Parameters
| * Workspace-ID or User-ID
* Reg-Code
* Password-Hash
* Device-ID
* Device-Key
* _optional:_ Domain

| Returns  | * 201 REGISTERED
* Workspace-ID
| Possible Errors | * 401 UNAUTHORIZED
|===

This command registers an account with a preprovisioned registration code. The user provides either the Workspace-ID or the User-ID set at pregistration along with the one-time-use registration code to the client application, which submits said information along with device identity info. If the domain for the workspace is different from that of the organization's server -- a common occurrence for service providers -- it is also required. Assuming that all the information matches, the server provisions the workspace the same way as with `REGISTER`. The registration code itself is a passphrase up to 128 UTF-8 code points in length. `401 UNAUTHORIZED` is returned if the registration combination is invalid. This command handles preregistration failures similar to LOGIN failures: if the login failure limit is reached, `405 TERMINATED` is returned and the connection is closed.

=== REGISTER

_Creates a new workspace_

[cols="1,3a"]
|===
| Parameters
| * Workspace-ID
* Password-Hash
* Device-ID
* Device-Key
* _optional:_ User-ID

| Returns
| * Public mode: 201 REGISTERED
** Domain
* Network mode: 201 REGISTERED
** Domain
* Moderated mode: 101 PENDING
** Domain
* Private mode: 304 REGISTRATION CLOSED
|===

Requests the creation of a new workspace. This command MAY be sent from unauthenticated or authenticated states. For public and network registration modes, success is returned unless a problem has been encountered. If network registration is used and the client is outside the permitted subnet(s), `304 REGISTRATION CLOSED` is returned. This response is also given if a registration request is made to a server with private registration. A successful request for moderated registration returns `101 PENDING`, indicating that the user must wait for the administrator to approve the request before login is possible, but the device is tentatively given a device ID. For servers utilizing private registration, this command is not used. Instead, an administrator uses the PREREG command while logged into the server locally to register accounts on users’ behalf.

`Workspace-ID` contains a client-generated UUID. In the event that the `Workspace-ID` or `User-ID` already exists on the server, `408 RESOURCE EXISTS` is returned with an attached `Field` value containing the name of the parameter with the existing resource ('User-ID' or 'Workspace-ID'). In such an event, it is permissible – and even expected – that the client will generate a new workspace ID and resubmit. `Device-ID` is simply another UUID generated by the client and is unique to the workspace. The `Device-Key` is the device's encryption key in CryptoString format. Each device is expected to have a unique encryption key.

=== RESETPASSWORD

_Resets a workspace's password_

[cols="1,3a"]
|===
| Parameters
| * Workspace-ID
* _optional:_ Reset-Code
* _optional:_ Expires

| Returns
| * 200 OK
** Reset-Code
** Expires
|===

This command requires admin provileges. It creates an alternate authentication method for a user so that they can change their password. Reset-Code is an optional parameter which contains a character string used as a password to authenticate the password reset. The reset code MUST be a minimum of 8 Unicode code points if specified. If it is not specified, the server SHOULD generate one using the https://en.wikipedia.org/wiki/Diceware[Diceware] method with a minimum of 4 words and an appropriate word list. Expires is the date and time when the reset code expires in the compact https://en.wikipedia.org/wiki/ISO_8601[ISO 8601] format `YYYYMMDDTHHMMSSZ` in UTC time. If not specified, the server will set the expiration time. By default, a 60-minute expiration time is chosen. The expiration time MUST NOT be any shorter than 10 minutes and no longer than 48 hours. 

=== SERVERID

_Enables a server to identify itself prior to delivering items_

[cols="1,3a"]
|===
| Parameters | * Domain
| Returns
| . 100 CONTINUE
* Challenge
. 200 OK
| Possible Errors | * 308 DELIVERY DELAY NOT REACHED
|===

Servers who intend to deliver items must initiate a session with this command. The exact process is detailed in the section below entitled, "Server Authentication for Message Delivery". 

=== SETPASSWORD

_Updates the password for the workspace_

[cols="1,3a"]
|===
| Parameters
| * Password-Hash
* NewPassword-Hash
| Returns | * 200 OK
| Possible Errors | * 402 AUTHENTICATION FAILURE
|===

A client will send this command when the user wishes to update their password. It requires the hash of both the old and new passwords in order to process the request. If the old hash does not match the current password’s hash, a `402 AUTHENTICATION FAILURE` response is sent and no password change is made.

=== SETSTATUS

_Sets the status of a workspace_

[cols="1,3a"]
|===
| Parameters
| * Workspace-ID
* Status
| Returns | * 200 OK
| Possible Errors | * 403 FORBIDDEN
* 404 NOT FOUND
|===

This command requires administrator privileges. It is used to change the activity status of a workspace. A workspace pending approval, such as when the server is running in moderated registration mode, can be approved with this command. It can also be used to disable a workspace without deleting it. `403 FORBIDDEN` is returned if this command is issued from a workspace without administrator permissions. The only valid status codes are 'active', 'approved', and 'disabled'.

=== UNREGISTER

_Deactivates a workspace_

[cols="1,3a"]
|===
| Parameters
| * Password-Hash
| * Workspace-ID _(admin only)_
| Returns
| * Public mode: 202 UNREGISTERED
* Moderated mode: 101 PENDING
* Network mode: 202 UNREGISTERED
* Private mode: 101 PENDING
| Possible Errors | * 401 UNAUTHORIZED
|===

Permanently deactivates a workspace. When a client sends this command, the server validates the password hash in the same way as the PASSWORD command. Assuming there is a match, the server continues. For servers configured for network or public registration, the server deletes all files in the workspace and removes all information about the workspace EXCEPT for the workspace ID, domain (if applicable), and associated user ID. These are retained so that those pieces of information cannot be reused. Once complete, `202 UNREGISTERED` is returned. For servers configured for moderated or private registration, an unregistration request is submitted to the administrator for approval. Once approved by the administrator, the workspace is deleted.

=== USERCARD

_Retrieve user keycard_

[cols="1,3a"]
|===
| Parameters
| * Owner
* Start-Index
* _optional:_ End-Index

| Returns
| * 104 TRANSFER
** Item-Count
** Total-Size
|===

Requests part or all of a user’s keycard, given an address, the starting index, and possibly an optional end index. The `Owner` parameter can either be a Mensago address, a workspace address, or a workspace ID. The client is not required to be authenticated for this command. If the ending index is omitted, all entries starting with the specified entry through the user’s current keycard are returned.

Once the command is submitted, the server responds with the number of entries and the total byte size of the transfer. The server is expected to respond with an empty TRANSFER command to confirm the transfer. Once confirmed, the server transmits the all of the requested entries. Each keycard entry has a `----- BEGIN USER ENTRY -----` header line and a `----- END USER ENTRY -----` footer line. Both are markers of the entry data without being part of the entries themselves. `400 BAD REQUEST` is returned if `end_index` is less than `start_index`. `404 NOT FOUND` is returned if the server cannot find the specified address or if there are no entries for the specified address.

== Server Authentication

Unlike e-mail the Mensago platform uses the same protocol for both sending e-mail externally as it does for interacting with clients. When a server intends to deliver messages to another server, it must authenticate like any other device. This process establishes the server's identity and is designed to prevent a number of different bad behaviors. The terms *receiver* and *sender* refer to the server for the recipient's domain and the server for the sender's domain, respectively.

1. The sender receives the destination domain as part of the upload process and the location of the message data in the filesystem.
2. The sender checks the domain against its internal list of managed domains. If it manages the destination domain, the server decrypts the recipient information, moves the message to the appropriate workspace location, and notifies the client of the new message. Otherwise, it continues the delivery process.
3. The sender performs a DNS lookup for the domain and obtains the receiver's primary encryption key (PEK) from its DNS record. If the sender is unable to find a DNS record for the domain, a bounce message is placed in the sending user's /new folder and the process ends.
4. The sender connects to port 2001 on the receiver. It then generates a 32-byte random challenge (hereafter Challenge A), Base85 encodes it, encrypts it with the receiver's PEK, and then Base85 encodes the encrypted version.
5. The sender begins the server authentication process by issuing the SERVERID command with Challenge A and its own domain attached.
6. The receiver performs a DNS lookup for the sender's domain and obtains the sender's PEK from its DNS record. If the receiver is unable to find a record for the domain, it returns a `306 KEY REQUEST FAILURE` error. If the lookup succeeds, but the server's fully-qualified domain name is not part of the record, `403 FORBIDDEN` is returned.
7. The receiver generates a 32-byte random challenge (hereafter Challenge B), Base85 encodes, encrypts it with the sender's PEK, and Base85 encodes the encrypted result.
8. The receiver decodes and decrypts Challenge A, but retains the Base85 encoding of the decrypted data. It creates a response message with the code `200 OK`, attaches the decrypted Challenge A and the encrypted Challenge B to the response message, and transmits it to the sender.
9. The sender receives the response from the receiver and checks the decrypted Challenge A, decrypts Challenge B, and retains the decrypted data's Base85 encoding.
10. The sender issues a second SERVERID command with the decrypted Challenge B attached.
11. The receiver checks the decrypted Challenge B response. If the sender exceeded the delivery failure rate configured on the receiver, the receiver sends `308 DELIVERY DELAY NOT REACHED` in response until the cooldown period has passed. Otherwise the receiver issues a `200 OK`, both servers have authenticated to one another, and message transmission can commence.
